
})
test_that("initial_data function raises error if input data file does
not exist", {
# Call the function with a non-existent file path
expect_error(
initial_data("./tests/testthat/helpers/data/nonexistent_file.csv",
col_names))
})
test_that("initial_data function raises error if input is not a CSV file", {
# Create a non-CSV file
file.create("./tests/testthat/helpers/data/noncsv_file.txt")
# Call the function with the non-CSV file
expect_error(initial_data("./data/noncsv_file.txt", col_names))
# Delete the non-CSV file
file.remove("./tests/testthat/helpers/data/noncsv_file.txt")
})
test_that("initial_data function raises error if input data file is empty", {
# Create an empty CSV file
write.csv(data.frame(), "./tests/testthat/helpers/data/empty_file.csv")
# Call the function with the empty CSV file
expect_error(initial_data("./tests/testthat/helpers/data/empty_file.csv",
col_names))
# Delete the empty CSV file
file.remove("./tests/testthat/helpers/data/empty_file.csv")
})
test_that("initial_data function raises error if number of column names does
not match number of columns in input data", {
# Create a column names vector with a different length than the number of
# columns in the input data
col_names_wrong <- c("col1", "col2")
# Call the function with the mismatched column names vector
expect_error(initial_data("./tests/testthat/helpers/data/data_set.csv",
col_names_wrong))
})
check()
check()
# Test cases
test_that("initial_data function reads data and sets column names correctly", {
# Call the function
actual_data <- initial_data("./tests/testthat/helpers/data/data_set.csv",
col_names)
# Test that the data has the expected number of observations
expect_equal(nrow(actual_data), nrow(expected_data))
# Test that the data has the expected column names
expect_equal(colnames(actual_data), colnames(expected_data))
# Test that the function returns a data frame
expect_type(actual_data, "list")
})
styler:::style_active_file()
# Load expected input and output data, and initial_data script from R folder
# Test cases
test_that("initial_data function reads data and sets column names correctly", {
# Set helpers and call the function
data_set <- data.frame(
x = c(1, 2, 3),
y = c(4, 5, 6),
z = c(7, 8, 9)
)
write.csv(data_set, "./tests/testthat/helpers/data/data_set.csv",
row.names = FALSE
)
# Defining column names
col_names <- c("col1", "col2", "col3")
# Defining expected data
expected_data <- data.frame(
col1 = c(1, 2, 3),
col2 = c(4, 5, 6),
col3 = c(7, 8, 9)
)
actual_data <- initial_data(
"./tests/testthat/helpers/data/data_set.csv",
col_names
)
# Test that the data has the expected number of observations
expect_equal(nrow(actual_data), nrow(expected_data))
# Test that the data has the expected column names
expect_equal(colnames(actual_data), colnames(expected_data))
# Test that the function returns a data frame
expect_type(actual_data, "list")
# Delete the helper file
file.remove("./tests/testthat/helpers/data/data_set.csv")
})
test_that("initial_data function raises error if input data file does
not exist", {
# Call the function with a non-existent file path
expect_error(
initial_data(
"./tests/testthat/helpers/data/nonexistent_file.csv",
col_names
)
)
})
test_that("initial_data function raises error if input is not a CSV file", {
# Create a non-CSV file
file.create("./tests/testthat/helpers/data/noncsv_file.txt")
# Call the function with the non-CSV file
expect_error(initial_data(
"./tests/testthat/helpers/data/noncsv_file.txt",
col_names
))
# Delete the non-CSV file
file.remove("./tests/testthat/helpers/data/noncsv_file.txt")
})
test_that("initial_data function raises error if input data file is empty", {
# Create an empty CSV file
write.csv(data.frame(), "./tests/testthat/helpers/data/empty_file.csv")
# Call the function with the empty CSV file
expect_error(initial_data(
"./tests/testthat/helpers/data/empty_file.csv",
col_names
))
# Delete the empty CSV file
file.remove("./tests/testthat/helpers/data/empty_file.csv")
})
test_that("initial_data function raises error if number of column names does
not match number of columns in input data", {
# Set up helper data
data_set <- data.frame(
x = c(1, 2, 3),
y = c(4, 5, 6),
z = c(7, 8, 9)
)
write.csv(data_set, "./tests/testthat/helpers/data/data_set.csv",
row.names = FALSE
)
# Create a column names vector with a different length than the number of
# columns in the input data
col_names_wrong <- c("col1", "col2")
# Call the function with the mismatched column names vector
expect_error(initial_data(
"./tests/testthat/helpers/data/data_set.csv",
col_names_wrong
))
# Delete the helper file
file.remove("./tests/testthat/helpers/data/data_set.csv")
})
load_all()
?initial_data
test()
check()
load_all()
document()
document()
document()
?split_dataset
load_all()
document()
check()
use_test(split_dataset())
library(rsample)
use_test(split_dataset
\\]\
use_test(split_dataset)
use_test("split_dataset")
styler:::style_active_file()
load_all()
# Define the split_dataset function
split_dataset <- function(data_set, strata_variable, predictor) {
split <- initial_split(data_set, prop = 0.75, strata = strata_variable)
training_data <- training(split)
testing_data <- testing(split)
return(list(training_data, testing_data))
}
# Create a helper script to provide data for the tests
# Example data
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
# Create expected training and testing datasets
split <- initial_split(data_set, prop = 0.75, strata = strata_variable)
expected_training_data <- training(split)
expected_testing_data <- testing(split)
load_all()
check()
library(rsample)
test()
test()
check()
document()
check()
check()
View(data_set)
load_all()
check()
test()
test_that("split_dataset function splits data set into training and testing
sets correctly", {
# Call the function
set.seed(123)
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the training set has the expected number of observations
expect_equal(nrow(actual_split[[1]]), nrow(expected_training_data))
# Test that the testing set has the expected number of observations
expect_equal(nrow(actual_split[[2]]), nrow(expected_testing_data))
# Test that the training set and testing set are mutually exclusive
expect_equal(intersect(
rownames(actual_split[[1]]),
rownames(actual_split[[2]])
), character(0))
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_is(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_is(actual_split[[1]], "data.frame")
expect_is(actual_split[[2]], "data.frame")
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_is(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_is(actual_split[[1]], "data.frame")
expect_is(actual_split[[2]], "data.frame")
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_is(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_is(actual_split[[1]], "data.frame")
expect_is(actual_split[[2]], "data.frame")
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_type(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_type(actual_split[[1]], "data.frame")
expect_type(actual_split[[2]], "data.frame")
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_type(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_type(actual_split[[1]], "list")
expect_type(actual_split[[2]], "lists")
})
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_type(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_type(actual_split[[1]], "list")
expect_type(actual_split[[2]], "list")
})
test_that("split_dataset function splits data set into training and testing
sets correctly", {
# Call the function
set.seed(123)
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the training set has the expected number of observations
expect_equal(nrow(actual_split[[1]]), nrow(expected_training_data))
# Test that the testing set has the expected number of observations
expect_equal(nrow(actual_split[[2]]), nrow(expected_testing_data))
# Test that the training set and testing set are mutually exclusive
expect_equal(intersect(
rownames(actual_split[[1]]),
rownames(actual_split[[2]])
), character(0))
})
styler:::style_active_file()
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the function returns a list with two data frames
expect_type(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_type(actual_split[[1]], "list")
expect_type(actual_split[[2]], "list")
})
test_that("split_dataset function splits data set into training and testing
sets correctly", {
# Create a helper script to provide data for the tests
# Example data
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
# Create expected training and testing datasets
split <- initial_split(data_set, prop = 0.75, strata = strata_variable)
expected_training_data <- training(split)
expected_testing_data <- testing(split)
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the training set has the expected number of observations
expect_equal(nrow(actual_split[[1]]), nrow(expected_training_data))
# Test that the testing set has the expected number of observations
expect_equal(nrow(actual_split[[2]]), nrow(expected_testing_data))
# Test that the training set and testing set are mutually exclusive
expect_equal(intersect(
rownames(actual_split[[1]]),
rownames(actual_split[[2]])
), character(0))
})
test_that("split_dataset function splits data set into training and testing
sets correctly", {
# Create a helper script to provide data for the tests
# Example data
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
# Create expected training and testing datasets
split <- initial_split(data_set, prop = 0.75, strata = strata_variable)
expected_training_data <- training(split)
expected_testing_data <- testing(split)
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the training set has the expected number of observations
expect_equal(nrow(actual_split[[1]]), nrow(expected_training_data))
# Test that the testing set has the expected number of observations
expect_equal(nrow(actual_split[[2]]), nrow(expected_testing_data))
# Test that the training set and testing set are mutually exclusive
expect_equal(intersect(
rownames(actual_split[[1]]),
rownames(actual_split[[2]])
), character(0))
})
test_that("split_dataset function splits data set into training and testing
sets with correct proportion", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, strata_variable, predictor)
# Test that the proportion of observations in the training set is correct
expect_equal(nrow(actual_split[[1]]) / nrow(data_set), 0.75, tolerance = 0.02)
# Test that the proportion of observations in the testing set is correct
expect_equal(nrow(actual_split[[2]]) / nrow(data_set), 0.26, tolerance = 0.02)
})
test()
test()
# Define test cases
test_that("split_dataset function returns a list with two data frames", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, all_of(strata_variable), all_of(predictor))
# Test that the function returns a list with two data frames
expect_type(actual_split, "list")
expect_equal(length(actual_split), 2)
expect_type(actual_split[[1]], "list")
expect_type(actual_split[[2]], "list")
})
test_that("split_dataset function splits data set into training and testing
sets correctly", {
# Create a helper script to provide data for the tests
# Example data
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
# Create expected training and testing datasets
split <- initial_split(data_set, prop = 0.75, strata = all_of(strata_variable))
expected_training_data <- training(split)
expected_testing_data <- testing(split)
actual_split <- split_dataset(data_set, all_of(strata_variable), all_of(predictor))
# Test that the training set has the expected number of observations
expect_equal(nrow(actual_split[[1]]), nrow(expected_training_data))
# Test that the testing set has the expected number of observations
expect_equal(nrow(actual_split[[2]]), nrow(expected_testing_data))
# Test that the training set and testing set are mutually exclusive
expect_equal(intersect(
rownames(actual_split[[1]]),
rownames(actual_split[[2]])
), character(0))
})
test_that("split_dataset function splits data set into training and testing
sets with correct proportion", {
# Call the function
set.seed(123)
data_set <- data.frame(
x = rnorm(100),
y = sample(c("A", "B", "C"), 100, replace = TRUE),
z = rnorm(100)
)
strata_variable <- "y"
predictor <- "x"
actual_split <- split_dataset(data_set, all_of(strata_variable), all_of(predictor))
# Test that the proportion of observations in the training set is correct
expect_equal(nrow(actual_split[[1]]) / nrow(data_set), 0.75, tolerance = 0.02)
# Test that the proportion of observations in the testing set is correct
expect_equal(nrow(actual_split[[2]]) / nrow(data_set), 0.26, tolerance = 0.02)
})
test()
check()
load_all()
check()
test()
check()
check()
check()
check()
load_all()
document()
?accuracy_plot
check()
check()
check()
check()
?scatterplot
?horizontal_hist
check()
check()
styler:::style_active_file()
accuracy_plot <- function(workflow_data, x_label, y_label, plot_title) {
options(repr.plot.width = 12, repr.plot.width = 12)
accuracy <- filter(workflow_data, .metric == "accuracy")
acc_plot <- ggplot(accuracy, aes(x = neighbors, y = mean)) +
geom_point() +
geom_line() +
labs(x = x_label, y = y_label, title = plot_title) +
theme(text = element_text(size = 20)) +
scale_x_continuous(breaks = c(1:30))
return(acc_plot)
}
load_all()
check()
load_all()
check()
=======
test_that("create_knn_spec sets the engine to kknn", {
test_spec <- parsnip::nearest_neighbor(
weight_func = "rectangular",
neighbors = tune()
) %>%
parsnip::set_engine("kknn") %>%
parsnip::set_mode("classification")
expected_engine <- "kknn"
expect_equal(test_spec$engine, expected_engine, "Expected engine to be kknn")
})
# Test case 3
test_that("create_knn_spec returns a model specification object", {
test_spec <- parsnip::nearest_neighbor(
weight_func = "rectangular",
neighbors = tune()
) %>%
parsnip::set_engine("kknn") %>%
parsnip::set_mode("classification")
expected_spec_class <- "model_spec"
expect_s3_class(test_spec, expected_spec_class)
})
# Test case 4
test_that("weight_func is a character", {
expect_error(create_knn_spec(123), "weight_func must be a character")
})
# Test case 5
test_that("create_knn_spec throws an error when weight_func is empty", {
expect_error(
create_knn_spec(""),
"weight_func must not be an empty string"
)
})
# Test case 6
test_that("create_knn_spec throws an error when no weight_func is passed", {
expect_error(
create_knn_spec(),
"weight_func must be provided"
)
})
install.packages(c("cachem", "cli", "colorspace", "commonmark", "cowsay", "curl", "dials", "dplyr", "fansi", "fastmap", "fs", "htmltools", "htmlwidgets", "igraph", "ipred", "IRkernel", "markdown", "modeldata", "modelenv", "pbdZMQ", "prodlim", "ps", "quantmod", "Rcpp", "renv", "repr", "stringi", "testthat", "tibble", "timechange", "tune", "utf8", "workflows", "workflowsets", "xfun"))
install.packages(c("cachem", "cli", "colorspace", "commonmark", "cowsay", "curl", "dials", "dplyr", "fansi", "fastmap", "fs", "htmltools", "htmlwidgets", "igraph", "ipred", "IRkernel", "markdown", "modeldata", "modelenv", "pbdZMQ", "prodlim", "ps", "quantmod", "Rcpp", "renv", "repr", "stringi", "testthat", "tibble", "timechange", "tune", "utf8", "workflows", "workflowsets", "xfun"))
install.packages(c("cachem", "cli", "colorspace", "commonmark", "cowsay", "curl", "dials", "dplyr", "fansi", "fastmap", "fs", "htmltools", "htmlwidgets", "igraph", "ipred", "IRkernel", "markdown", "modeldata", "modelenv", "pbdZMQ", "prodlim", "ps", "quantmod", "Rcpp", "renv", "repr", "stringi", "testthat", "tibble", "timechange", "tune", "utf8", "workflows", "workflowsets", "xfun"))
test()
library(devtools)
test()
use_r("create_recipe")
document()
use_test("create_recipe")
load_all()
check()
#' Create a recipe for a dataframe
#'
#' This function creates a recipe object for use in a modeling workflow.
#' The recipe includes a formula where the response variable is the
#' `response_var`and all other columns in the input dataframe are used as
#' predictors. The recipe object also includes steps for scaling and centering
#' the predictor variables.
#'
#' @param data A dataframe containing the data.
#' @param response_var A string specifying the name of the response variable.
#' @return A recipe object for use in a workflow.
#' @import recipes
#' @export
#' @examples
#' create_recipe(drug_data, "Cannabis")
create_recipe <- function(data, response_var) {
if (is.null(data)) {
stop("data must be provided.")
}
if (is.null(response_var)) {
stop("response_var must be provided.")
}
if (!is.character(response_var)) {
stop("response_var must be a character string.")
}
if (!response_var %in% colnames(data)) {
stop("response_var must be a column in data.")
}
recipe <-
recipes::recipe(as.formula(paste0(response_var, " ~ .")), data = data) %>%
recipes::step_scale(all_predictors()) %>%
recipes::step_center(all_predictors())
return(recipe)
}
check()
# Test case 1
test_that("create_recipe returns a recipe object", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
test_recipe <- recipes::recipe(as.formula(paste0(response_var, " ~ .")),
data = df
) %>%
recipes::step_scale(all_predictors()) %>%
recipes::step_center(all_predictors())
expected_recipe_class <- "recipe"
expect_s3_class(test_recipe, expected_recipe_class)
})
check()
document()
rm(list = c("create_recipe"))
document()
load_all()
check()
install()
check()
use_package("parsnip")
use_package("recipes")
check()
document()
check())
check()
check()
# Test case 1
test_that("create_recipe returns a recipe object", {
response_var = "Cannabis"
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
test_recipe <- recipes::recipe(as.formula(paste0(response_var, " ~ .")),
data = df
) %>%
recipes::step_scale(all_predictors()) %>%
recipes::step_center(all_predictors())
expected_recipe_class <- "recipe"
expect_s3_class(test_recipe, expected_recipe_class)
})
# Test case 2
test_that("create_recipe throws an error if response variable not in dataset", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
not_response_var <- "Test"
expect_error(
create_recipe(df, not_response_var),
"response_var must be a column in data."
)
})
# Test case 3
test_that("create_recipe throws an error when data is missing", {
response_var = "Cannabis"
expect_error(create_recipe(NULL, response_var), "data must be provided.")
})
# Test case 4
test_that("create_recipe throws an error when data is missing", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
expect_error(create_recipe(df, NULL), "response_var must be provided.")
})
# Test case 5
test_that("create_recipe throws an error when data is missing", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
expect_error(
create_recipe(df, 123),
"response_var must be a character string."
)
})
#' Create a recipe for a dataframe
#'
#' This function creates a recipe object for use in a modeling workflow.
#' The recipe includes a formula where the response variable is the
#' `response_var`and all other columns in the input dataframe are used as
#' predictors. The recipe object also includes steps for scaling and centering
#' the predictor variables.
#'
#' @param data A dataframe containing the data.
#' @param response_var A string specifying the name of the response variable.
#' @return A recipe object for use in a workflow.
#' @import recipes
#' @export
#' @examples
#' create_recipe(drug_data, "Cannabis")
create_recipe <- function(data, response_var) {
if (is.null(data)) {
stop("data must be provided.")
}
if (is.null(response_var)) {
stop("response_var must be provided.")
}
if (!is.character(response_var)) {
stop("response_var must be a character string.")
}
if (!response_var %in% colnames(data)) {
stop("response_var must be a column in data.")
}
recipe <-
recipes::recipe(as.formula(paste0(response_var, " ~ .")), data = data) %>%
recipes::step_scale(all_predictors()) %>%
recipes::step_center(all_predictors())
return(recipe)
}
document()
rm(list = c("create_recipe"))
load_all()
check()
install()
check()
use-r("create_vfold")
use_r("create_vfold")
document()
?create_vfold
use_test("create_vfold")
# Test case 1
test_that("create_vfold returns a valid vfold object", {
test_vfold <- rsample::vfold_cv(df, v = v_good, strata = response_var)
expected_num_splits <- 5
expect_is(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
# Test case 2
test_that("create_vfold throws an error when v is missing", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
expect_error(create_vfold(df, NULL, response_var), "v must be provided.")
})
# Test case 1
test_that("create_vfold returns a valid vfold object", {
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expect_is(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
# Test case 1
test_that("create_vfold returns a valid vfold object", {
response_var = "Cannabis"
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expect_is(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
# Test case 1
test_that("create_vfold returns a valid vfold object", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expect_is(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
# Test case 1
test_that("create_vfold returns a valid vfold object", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expected_vfold_class <- "vfold_cv"
expect_is(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
# Test case 2
test_that("create_vfold throws an error when v is missing", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
expect_error(create_vfold(df, NULL, response_var), "v must be provided.")
})
# Test case 3
test_that("create_vfold throws an error when v is not numeric", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
v_string <- "five"
response_var <- "Cannabis"
expect_error(
create_vfold(df, v_string, response_var),
"v must be a numeric value."
)
})
# Test case 4
test_that("create_vfold throws an error when v is less than 2", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
v_small <- 1
response_var <- "Cannabis"
expect_error(
create_vfold(df, v_small, response_var),
"v must be greater than or equal to 2."
)
})
expect_type(test_vfold, expected_vfold_class)
# Test case 1
test_that("create_vfold returns a valid vfold object", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expected_vfold_class <- "vfold_cv"
expect_type(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
test()
# Test case 1
test_that("create_vfold returns a valid vfold object", {
df <- data.frame(
Age = c(3, 5, 6, 7, 8, 9),
Gender = c(-0.95197, 0.48246, -0.48246, -0.48246, 0.48246, -0.48246),
Nscore = c(-0.14882, -0.67825, -0.46725, -1.32828, 0.62967, -0.24649),
Escore = c(-0.80615, -0.30033, -1.09207, 1.93886, 2.57309, 0.00332),
Oscore = c(-0.01928, -1.55521, -0.45174, -0.84732, -0.97631, -1.42424),
Ascore = c(0.59042, 2.03972, -0.30172, -0.30172, 0.76096, 0.59042),
Nicotine = c(0, 1, 1, 0, 1, 1),
Cannabis = c("no", "no", "no", "no", "no", "no")
)
response_var <- "Cannabis"
test_vfold <- rsample::vfold_cv(df, v = 5, strata = response_var)
expected_num_splits <- 5
expected_vfold_class <- "vfold_cv"
expect_s3_class(test_vfold, expected_vfold_class)
expect_equal(length(test_vfold$splits), expected_num_splits)
})
load_all()
check()
load_all()
check()
document()
load_all()
check()
install()
check()
remove.packages("group05pkg")
install.packages("group05pkg")
install.packages("group05pkg")
check()
remove.packages("rdb")
system.file("R", package = "group05pkg")
unlink(file.path(system.file("R", package = "group05pkg"), "group05pkg.rdb"))
install()
document()
install.packages("group5pkg")
document()
library(devtools)
check()
library(devtools)
document()
check()
install()
check()
check()
install()
check()
install()
check()
use_r("create_grid")
document()
?create_grid
document()
?create_grid
use_test("create_grid")
# Test case 1
test_that("create_grid creates a grid with the correct number of neighbors", {
test_grid <- tibble::tibble(neighbors = seq(min_neighbors, max_neighbors))
expected_num_rows_grid <- max_neighbors - min_neighbors + 1
expect_equal(nrow(test_grid), expected_num_rows_grid)
})
library(testthat)
# Test case 1
test_that("create_grid creates a grid with the correct number of neighbors", {
test_grid <- tibble::tibble(neighbors = seq(min_neighbors, max_neighbors))
expected_num_rows_grid <- max_neighbors - min_neighbors + 1
expect_equal(nrow(test_grid), expected_num_rows_grid)
})
# Test case 1
test_that("create_grid creates a grid with the correct number of neighbors", {
min_neighbors <- 5
max_neighbors <- 10
test_grid <- tibble::tibble(neighbors = seq(min_neighbors, max_neighbors))
expected_num_rows_grid <- max_neighbors - min_neighbors + 1
expect_equal(nrow(test_grid), expected_num_rows_grid)
})
# Test case 2
test_that("create_grid throws an error when input values are not numeric", {
expect_error(create_grid("a", 5), "Input values must be numeric.")
expect_error(create_grid(1, "b"), "Input values must be numeric.")
})
# Test case 3
test_that("create_grid throws an error when input values are less than 1", {
expect_error(
create_grid(0, 5),
"Input values must be greater than or equal to 1."
)
expect_error(
create_grid(1, -2),
"Input values must be greater than or equal to 1."
)
})
# Test case 4
test_that("create_grid throws an error when min_neighbors is greater
than max_neighbors", {
expect_error(
create_grid(5, 2),
"Minimum value cannot be greater than maximum value."
)
})
# Test case 5
test_that("create_grid throws an error when min_neighbors is missing", {
expect_error(create_grid(NULL, 5), "min_neighbors must be provided.")
})
# Test case 6
test_that("create_grid throws an error when max_neighbors is missing", {
expect_error(create_grid(2, NULL), "max_neighbors must be provided.")
})
# Test case 7
test_that("create_grid returns a tibble", {
expect_s3_class(create_grid(2, 5), expected_tibble)
})
# Test case 7
test_that("create_grid returns a tibble", {
expected_tibble <- "tbl_df"
expect_s3_class(create_grid(2, 5), expected_tibble)
})
test()
load_all()
check()
install()
check()
